<?php
/**
 * Created by PhpStorm.
 * User: Administrator
 * Date: 2018/4/17
 * Time: 15:44
 */

namespace App\Http\Controllers\SecondExploit;


use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Http\Requests;


/**
 * Class OrderManageController
 * @package App\Http\Controllers\SecondExploit
 * 订单管理
 */
class OrderManageController extends Controller{



    //1.会员主动创建订单（1.直接购买   2，加入购物车购买） 注：这里暂时不支持直接购买  ---->走线上支付
    public function createV2Orders(Request $request)
    {


        //1表示使用新地址     2表示使用已有的地址（如果传地址id则使用该地址，否则使用该用户的默认地址，如果没有默认地址则报错，提示地址没填写）
        if(empty($request->flag)) return $this->setStatusCode(9999)->respondWithError($this->message);

        if($request->flag == 1){ //使用新地址

            $validator = $this->setRules([
                'ss' => 'required|string',
                'name' => 'required|string', //收货人姓名
                'mobile' =>[ //收货人电话： 既能验证座机号码又能验证手机号码的正则
                    'required',
                    'regex:/^1[345678][0-9]{9}$|(^0\\d{2}-?\\d{8}$)|(^0\\d{3}-?\\d{7}$)|(^\\(0\\d{2}\\)-?\\d{8}$)|(^\\(0\\d{3}\\)-?\\d{7}$)$/'
                ],
                'area_id' => 'string|between:6,6', //省市区id
                'address' => 'required|string', //收货详细地址
                'user_remark'=>'string',//用户下单备注信息
            ])
                ->_validate($request->all());
            if (!$validator)  return $this->setStatusCode(9999)->respondWithError($this->message);

        }elseif($request->flag == 2){ //使用已有地址

            $validator = $this->setRules([
                'ss' => 'required|string',
                'name' => 'required|string', //收货人姓名
                'mobile' =>[ //收货人电话： 既能验证座机号码又能验证手机号码的正则
                    'required',
                    'regex:/^1[345678][0-9]{9}$|(^0\\d{2}-?\\d{8}$)|(^0\\d{3}-?\\d{7}$)|(^\\(0\\d{2}\\)-?\\d{8}$)|(^\\(0\\d{3}\\)-?\\d{7}$)$/'
                ],
                'address' => 'required|string', //收货详细地址
                'user_remark'=>'string',//用户下单备注信息
            ])
                ->_validate($request->all());
            if (!$validator)  return $this->setStatusCode(9999)->respondWithError($this->message);

        }else{ //如果$flag的值不为1，或者2那么就是无效的值
            return $this->setStatusCode(9999)->respondWithError($this->message);
        }

        $user_id = $this->getUserIdBySession($request->ss); //获取用户id
        //参数校验通过后，去查看购物车中选中的商品都有哪些
        $goods_info = \DB::table('ys_goods_car as a')
                            ->leftjoin('ys_goods as b','a.goods_id','=','b.id')
                            ->leftjoin('ys_goods_extend as d','a.ext_id','=','d.id')
                            ->leftjoin('ys_goods_image as c','a.goods_id','=','c.goods_id')
                            ->leftjoin('ys_supplier as e','a.supplier_id','=','e.id')
                            ->select('a.id as car_id','a.goods_id','a.supplier_id','a.number','a.ext_id',
                                        'b.name as goods_name','b.shipping_price','b.class_id','b.store_class',
                                        'c.image','d.name as spec_name','d.market_price','d.price','d.supplier_price',
                                         'd.num as repertory_num','d.cost_price','d.rebate_amount',
                                         'e.name as supplier_name','e.logo','e.free_shipping')
                            ->where('a.user_id',$user_id)
                            ->where('a.state',1) //1选中   0不选中
                            ->where('b.state',1) //0下架1上架
                            ->groupBy('a.id')
                            ->get();

        if(empty($goods_info)){ //没有找到商品信息 1043
            return $this->setStatusCode(1043)->respondWithError($this->message);
        }

      //需要计算如下几个因素：  总运费（如果单个供应商商品总额达到免邮之后，则该供应商底下的商品运费免去）
      //总利润（销售价-成本价）   总金额（需要支付的商品总价）    总返利金额（每个商品不同的返利加起来）

        $delete_carId_arr = [];  //需要清空的购物车id
        $supplier_id_class = [];//供销商id数组
        $update_extId_arr = []; //购买商品的扩展表id
        $supplier_shipping = []; //供应商免邮金额，以及购买的经销商商品
        $require_amount = 0; //总金额(等于总运费 + 商品总价)
        $all_profit = 0; //总利润
        $all_freight = 0; //总运费
        $return_profit = 0;//总返利金额


        /**
         * 根据购物车商品完成计算
         */
        foreach($goods_info as $k=>$v){

            array_push($delete_carId_arr,$v->car_id);
            array_push($supplier_id_class,$v->supplier_id);
            array_push($update_extId_arr,$v->ext_id);

            $all_profit += ($v->price  -  $v->cost_price) * $v->number;//总利润

            $return_profit  += $v->rebate_amount * $v->number;//总返利金额

        }



        $supplier_id_class = array_values(array_unique($supplier_id_class));//对供应商id数组去重

        foreach($supplier_id_class as $k=>$v){

            $supplier_shipping[$k]['all_supplier_shipping'] = 0;
            $supplier_shipping[$k]['price']  =  0;

            foreach($goods_info as $kk=>$vv){

                 if($v == $vv->supplier_id){

                     $supplier_shipping[$k]['supplier_id'] = $vv->supplier_id;//供应商id
                     $supplier_shipping[$k]['free_shipping'] = $vv->free_shipping;//供应商免邮价格
                     $supplier_shipping[$k]['all_supplier_shipping']  +=  $vv->shipping_price;//本次购买该供应商产品所有邮费总和
                     $supplier_shipping[$k]['price']  +=  $vv->number * $vv->price; //本次购买该供应商产品应该付钱总额
                 }
            }

        }


        //如果商品总额超过了供应商免邮价格，那么该供应商底下的所有产品都免邮费
        foreach($supplier_shipping as $k=>$v){
              if($v['price']  >= $v['free_shipping'] ){//商品总价大于等于免邮金额

                  $supplier_shipping[$k]['all_supplier_shipping'] = 0;//总邮费设置为0
              }
        }

        //计算总运费和总金额
        foreach($supplier_shipping as $k=>$v){
            $all_freight += $v['all_supplier_shipping']; //总运费
            $require_amount +=  ($v['all_supplier_shipping'] + $v['price']);//订单总金额
        }


        /**
         *  判断商品库存是否够
         */
        $complete_arr = []; //用于更新销量和库存
        //查询一下购买商品的详情,进而判断商品库存是否充足
        $tmp_goods_info = \DB::table('ys_goods_extend as a')
                            ->leftjoin('ys_goods as b','a.goods_id','=','b.id')
                            ->whereIn('a.id',$update_extId_arr)
                            ->select('a.id as ext_id','a.goods_id','a.num','b.sales')
                            ->get();



        foreach($goods_info as $k=>$v){
            foreach($tmp_goods_info as $kk=>$vv){
                if($v->ext_id == $vv->ext_id){
                    //进一步比较两个数据的大小，判断库存是否充足
                    if(($vv->num - $v->number) < 0){ //库存不足
                        return $this->setStatusCode(1046)->respondWithError($this->message);
                    }

                    $make_tmp_arr = [

                        'ext_id'=>$vv->ext_id,//商品扩展表id
                        'goods_id'=>$vv->goods_id, //商品id
                        'buy_num'=>$v->number, //购买数量
                        'rest_num'=>$vv->num, //库存剩余数量
                        'sales'=>$vv->sales //该商品销量
                    ];
                    array_push($complete_arr,$make_tmp_arr);
                }
            }
        }

        /**
         * 按经销商分别计算其购买其产品的总金额
         */
        $tmp_arr = array_fill(0,count($supplier_id_class),[]);
        foreach($goods_info as $k=>$v){
            foreach($supplier_id_class as $kk=>$vv){
                if($v->supplier_id == $vv){
                    array_push($tmp_arr[$kk],$v);
                }
            }
        }


        /**
         * 按照主订单和子订单需要的格式分别组装数据如下
         */
            //1.主订单 （主订单号  用户id  收货地址  收货人姓名  收货人手机号码  需要的总金额 支持返现的份数）
            $base_order_id =  generatorOrderIdNew();

            $base = [
                'id' => $base_order_id, //主订单id
                'user_id' => $user_id,
                'create_time' => date("Y-m-d H:i:s"),
                'state' => 0,//订单状态0未付款，1，已付款
                'receive_address'=>$request->address,//收货地址
                'require_amount'=>$require_amount,//需要的总金额
                'receive_mobile'=>$request->mobile, //收货人手机号码
                'receive_name'=>$request->name,//收货人姓名
                'all_profit'=>($all_profit > 0) ? $all_profit : 0, //该笔订单总利润
                'user_remark'=>$request->user_remark,//用户备注信息
                'all_rebate'=>$return_profit, //该笔订单总返利金额
                'shipping_price'=>$all_freight,//总运费

            ];

        //2.子订单 （主订单号 子订单号  子订单总金额 供应商id）
        //3.子订单和商品的对应表 （子订单id  商品id  购买数量）
        $sub_arr = []; //子订单
        $sub_goods = []; //子订单和商品对应数组

        foreach($tmp_arr as $k=>$v){

            $sub_order_id = generatorOrderIdNew(); //子订单id
            $price = 0; //购买该供应商所有商品的总价
            $shipping_price_tmp = 0; //运费
            if(is_array($v) && !empty($v)){

                foreach($v as $kk=>$vv){
                    $price += ($vv->number) * ($vv->price);
                    $shipping_price_tmp += $vv->shipping_price;

                    $sub_good_tmp = [
                        'sub_id' =>$sub_order_id,
                        'goods_id'=>$vv->goods_id,//商品id
                        'num'=>$vv->number, //商品数量
                        'ext_id'=>$vv->ext_id,//商品扩展表id
                        'price'=>$vv->price,//该规格商品价格
                        'name'=>$vv->spec_name,//该规格商品名称
                        'image'=>$vv->image,//该商品配图
                        'rebate_amount'=>$vv->rebate_amount,//该规格商品返利金额
                        'supplier_price'=>$vv->supplier_price,//供应商价格
                    ];
                    array_push($sub_goods,$sub_good_tmp);
                }


                $shipping_price = ($price >= $v[0]->free_shipping) ?  0 : $shipping_price_tmp;

                $sub = [
                    'id' =>$sub_order_id, //子订单id
                    'base_id'=>$base_order_id, //主订单id
                    'supplier_id'=>$v[0]->supplier_id,//供应商id
                    'price'=>$price,//购买该供应商所有商品的总价格
                    'shipping_price'=>$shipping_price,//购买该供应商产品所应付出的邮费总额
                ];
                array_push($sub_arr,$sub);

            }else{ //其实这一步错误是因为数据错误导致的
                return $this->setStatusCode(9998)->respondWithError($this->message);
            }
        }


        \DB::beginTransaction(); //开启事务
        //生成订单分为如下三步：
        //(1)生成主订单（包含地址信息和总金额信息）
        $insert1 = \DB::table('ys_base_order')->insert($base);

        //(2)生成子订单（每个经销商一条记录，记录条数等于经销商个数
        $insert2 =  \DB::table('ys_sub_order')->insert($sub_arr);

        //(3)生成子订单和商品的对应表信息
        $insert3 = \DB::table('ys_order_goods')->insert($sub_goods);

        //(4)如果使用新地址，则把新地址写入到地址库中去
        if($request->flag == 1) { //使用新地址
            //判断该用户是否有地址记录，如果有则直接插入该地址即可，如果没有则插入该地址，并且设置为默认地址
            $is_exist = \DB::table('ys_user_addresses')->where('user_id',$user_id)->first();
            $is_default = empty($is_exist) ? 1 : 0;
            $insert4 = \DB::table('ys_user_addresses')->insert([

                'user_id' => $user_id,
                'name' => addslashes($request->name),
                'mobile' => $request->mobile,
                'area_id' => empty($request->area_id) ? "" : $request->area_id,
                'address' => $request->address,
                'created_at' => \DB::Raw('now()'),
                'updated_at' => \DB::Raw('now()'),
                'is_default' => $is_default,
            ]);
        }else{
            $insert4 = 1;
        }

        //(5)如果付款成功，则把购物车中已购买的商品清空 $delete_carId_arr
        $delete = \DB::table('ys_goods_car')->where('user_id',$user_id)->whereIn('id',$delete_carId_arr)->delete();

        /**
         * 最后提交事务，并且返回主订单id
         */
        if ($insert1 && $insert2 && $insert3 && $insert4 && $delete) {
            \DB::commit();
            return  $this->respond($this->format(['order_id'=>$base_order_id]));
        }else {
            \DB::rollBack();
            return $this->setStatusCode(9998)->respondWithError($this->message);
        }


    }




    /**
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     *  2.员工给会员创建订单  ---->走线下支付
     *
     *  检查当前用户是否是员工，并且查看该被代替的用户手机号码是否存在系统内
     *  会员输入用户手机号，替用户购买（绑定用户该笔订单和该员工）
     *  下单直接成功，支付方式为线下支付，并且更新商品销量和库存
     */
    public function empV2GivCreOrders(Request $request)
    {

        //1表示使用新地址     2表示使用已有的地址（如果传地址id则使用该地址，否则使用该用户的默认地址，如果没有默认地址则报错，提示地址没填写）
        if(empty($request->flag)) return $this->setStatusCode(9999)->respondWithError($this->message);

        if($request->flag == 1){ //使用新地址

            $validator = $this->setRules([
                'ss' => 'required|string',
                'phone' => 'required|regex:/^1[34578][0-9]{9}$/', //会员的电话号码
                'name' => 'required|string', //收货人姓名
                'mobile' =>[ //收货人电话： 既能验证座机号码又能验证手机号码的正则
                    'required',
                    'regex:/^1[345678][0-9]{9}$|(^0\\d{2}-?\\d{8}$)|(^0\\d{3}-?\\d{7}$)|(^\\(0\\d{2}\\)-?\\d{8}$)|(^\\(0\\d{3}\\)-?\\d{7}$)$/'
                ],
                'area_id' => 'string|between:6,6', //省市区id
                'address' => 'required|string', //收货详细地址
                'user_remark'=>'string',//用户下单备注信息
            ])
                ->_validate($request->all());
            if (!$validator)  return $this->setStatusCode(9999)->respondWithError($this->message);

        }elseif($request->flag == 2){ //使用已有地址

            $validator = $this->setRules([
                'ss' => 'required|string',
                'phone' => 'required|regex:/^1[34578][0-9]{9}$/', //会员的电话号码
                'name' => 'required|string', //收货人姓名
                'mobile' =>[ //收货人电话： 既能验证座机号码又能验证手机号码的正则
                    'required',
                    'regex:/^1[345678][0-9]{9}$|(^0\\d{2}-?\\d{8}$)|(^0\\d{3}-?\\d{7}$)|(^\\(0\\d{2}\\)-?\\d{8}$)|(^\\(0\\d{3}\\)-?\\d{7}$)$/'
                ],
                'address' => 'required|string', //收货详细地址
                'user_remark'=>'string',//用户下单备注信息
            ])
                ->_validate($request->all());
            if (!$validator)  return $this->setStatusCode(9999)->respondWithError($this->message);

        }else{ //如果$flag的值不为1，或者2那么就是无效的值
            return $this->setStatusCode(9999)->respondWithError($this->message);
        }

        $user_id = $this->getUserIdBySession($request->ss); //获取员工id

        //首先查看会员手机号码是否存在，如果不存在则让其注册后再买
        $is_member = \DB::table('ys_member')->where('mobile',$request->phone)->first();
        if(empty($is_member)){ //该用户还不是会员
            return $this->setStatusCode(1044)->respondWithError($this->message);
        }
        //接着检查该购买者身份是否是员工（该接口仅限员工身份调用，用于替用户下单购买）
        $is_employee = \DB::table('ys_employee')->where('user_id',$user_id)->first();
        if(empty($is_employee)){ //您不是员工
            return $this->setStatusCode(1045)->respondWithError($this->message);
        }


        //参数校验通过后，去查看购物车中选中的商品都有哪些
        $goods_info = \DB::table('ys_goods_car as a')
            ->leftjoin('ys_goods as b','a.goods_id','=','b.id')
            ->leftjoin('ys_goods_extend as d','a.ext_id','=','d.id')
            ->leftjoin('ys_goods_image as c','a.goods_id','=','c.goods_id')
            ->leftjoin('ys_supplier as e','a.supplier_id','=','e.id')
            ->select('a.id as car_id','a.goods_id','a.supplier_id','a.number','a.ext_id',
                'b.name as goods_name','b.shipping_price','b.class_id','b.store_class',
                'c.image','d.name as spec_name','d.market_price','d.price','d.supplier_price',
                'd.num as repertory_num','d.cost_price','d.rebate_amount',
                'e.name as supplier_name','e.logo','e.free_shipping')
            ->where('a.user_id',$user_id)
            ->where('a.state',1) //1选中   0不选中
            ->where('b.state',1) //0下架1上架
            ->groupBy('a.id')
            ->get();

        if(empty($goods_info)){ //没有找到商品信息 1043
            return $this->setStatusCode(1043)->respondWithError($this->message);
        }

        //需要计算如下几个因素：  总运费（如果单个供应商商品总额达到免邮之后，则该供应商底下的商品运费免去）
        //总利润（销售价-成本价）   总金额（需要支付的商品总价）    总返利金额（每个商品不同的返利加起来）

        $delete_carId_arr = [];  //需要清空的购物车id
        $supplier_id_class = [];//供销商id数组
        $update_extId_arr = []; //购买商品的扩展表id
        $supplier_shipping = []; //供应商免邮金额，以及购买的经销商商品
        $require_amount = 0; //总金额(等于总运费 + 商品总价)
        $all_profit = 0; //总利润
        $all_freight = 0; //总运费
        $return_profit = 0;//总返利金额


        /**
         * 根据购物车商品完成计算
         */
        foreach($goods_info as $k=>$v){

            array_push($delete_carId_arr,$v->car_id);
            array_push($supplier_id_class,$v->supplier_id);
            array_push($update_extId_arr,$v->ext_id);

            $all_profit += ($v->price  -  $v->cost_price) * $v->number;//总利润

            $return_profit  += $v->rebate_amount * $v->number;//总返利金额

        }



        $supplier_id_class = array_values(array_unique($supplier_id_class));//对供应商id数组去重

        foreach($supplier_id_class as $k=>$v){

            $supplier_shipping[$k]['all_supplier_shipping'] = 0;
            $supplier_shipping[$k]['price']  =  0;

            foreach($goods_info as $kk=>$vv){

                if($v == $vv->supplier_id){

                    $supplier_shipping[$k]['supplier_id'] = $vv->supplier_id;//供应商id
                    $supplier_shipping[$k]['free_shipping'] = $vv->free_shipping;//供应商免邮价格
                    $supplier_shipping[$k]['all_supplier_shipping']  +=  $vv->shipping_price;//本次购买该供应商产品所有邮费总和
                    $supplier_shipping[$k]['price']  +=  $vv->number * $vv->price; //本次购买该供应商产品应该付钱总额
                }
            }

        }


        //如果商品总额超过了供应商免邮价格，那么该供应商底下的所有产品都免邮费
        foreach($supplier_shipping as $k=>$v){
            if($v['price']  >= $v['free_shipping'] ){//商品总价大于等于免邮金额

                $supplier_shipping[$k]['all_supplier_shipping'] = 0;//总邮费设置为0
            }
        }

        //计算总运费和总金额
        foreach($supplier_shipping as $k=>$v){
            $all_freight += $v['all_supplier_shipping']; //总运费
            $require_amount +=  ($v['all_supplier_shipping'] + $v['price']);//订单总金额
        }


        /**
         *  判断商品库存是否够
         */
        $complete_arr = []; //用于更新销量和库存
        //查询一下购买商品的详情,进而判断商品库存是否充足
        $tmp_goods_info = \DB::table('ys_goods_extend as a')
            ->leftjoin('ys_goods as b','a.goods_id','=','b.id')
            ->whereIn('a.id',$update_extId_arr)
            ->select('a.id as ext_id','a.goods_id','a.num','b.sales')
            ->get();



        foreach($goods_info as $k=>$v){
            foreach($tmp_goods_info as $kk=>$vv){
                if($v->ext_id == $vv->ext_id){
                    //进一步比较两个数据的大小，判断库存是否充足
                    if(($vv->num - $v->number) < 0){ //库存不足
                        return $this->setStatusCode(1046)->respondWithError($this->message);
                    }

                    $make_tmp_arr = [

                        'ext_id'=>$vv->ext_id,//商品扩展表id
                        'goods_id'=>$vv->goods_id, //商品id
                        'buy_num'=>$v->number, //购买数量
                        'rest_num'=>$vv->num, //库存剩余数量
                        'sales'=>$vv->sales //该商品销量
                    ];
                    array_push($complete_arr,$make_tmp_arr);
                }
            }
        }

        /**
         * 按经销商分别计算其购买其产品的总金额
         */
        $tmp_arr = array_fill(0,count($supplier_id_class),[]);
        foreach($goods_info as $k=>$v){
            foreach($supplier_id_class as $kk=>$vv){
                if($v->supplier_id == $vv){
                    array_push($tmp_arr[$kk],$v);
                }
            }
        }


        /**
         * 按照主订单和子订单需要的格式分别组装数据如下
         */
        //1.主订单 （主订单号  用户id  收货地址  收货人姓名  收货人手机号码  需要的总金额 支持返现的份数）
        $base_order_id =  generatorOrderIdNew();

        $base = [
            'id' => $base_order_id, //主订单id
            'user_id' => $is_member->user_id,
            'create_time' => date("Y-m-d H:i:s"),
            'pay_time'=>date("Y-m-d H:i:s"),
            'pay_type'=>2,//付款方式:1微信，2线下支付
            'employee_id'=>$user_id,//员工id也就是本次替用户购买者的id
            'state' => 1,//订单状态0未付款，1，已付款
            'receive_address'=>$request->address,//收货地址
            'require_amount'=>$require_amount,//需要的总金额
            'amount'=>$require_amount,//实际收到的总金额
            'receive_mobile'=>$request->mobile, //收货人手机号码
            'receive_name'=>$request->name,//收货人姓名
            'all_profit'=>($all_profit > 0) ? $all_profit : 0, //该笔订单总利润
            'user_remark'=>$request->user_remark,//用户备注信息
            'all_rebate'=>$return_profit, //该笔订单总返利金额
            'shipping_price'=>$all_freight,//总运费

        ];

        //2.子订单 （主订单号 子订单号  子订单总金额 供应商id）
        //3.子订单和商品的对应表 （子订单id  商品id  购买数量）
        $sub_arr = []; //子订单
        $sub_goods = []; //子订单和商品对应数组

        foreach($tmp_arr as $k=>$v){

            $sub_order_id = generatorOrderIdNew(); //子订单id
            $price = 0; //购买该供应商所有商品的总价
            $shipping_price_tmp = 0; //运费
            if(is_array($v) && !empty($v)){

                foreach($v as $kk=>$vv){
                    $price += ($vv->number) * ($vv->price);
                    $shipping_price_tmp += $vv->shipping_price;

                    $sub_good_tmp = [
                        'sub_id' =>$sub_order_id,
                        'goods_id'=>$vv->goods_id,//商品id
                        'num'=>$vv->number, //商品数量
                        'ext_id'=>$vv->ext_id,//商品扩展表id
                        'price'=>$vv->price,//该规格商品价格
                        'name'=>$vv->spec_name,//该规格商品名称
                        'image'=>$vv->image,//该商品配图
                        'rebate_amount'=>$vv->rebate_amount,//该规格商品返利金额
                        'supplier_price'=>$vv->supplier_price,//供应商价格
                    ];
                    array_push($sub_goods,$sub_good_tmp);
                }


                $shipping_price = ($price >= $v[0]->free_shipping) ?  0 : $shipping_price_tmp;

                $sub = [
                    'id' =>$sub_order_id, //子订单id
                    'base_id'=>$base_order_id, //主订单id
                    'supplier_id'=>$v[0]->supplier_id,//供应商id
                    'price'=>$price,//购买该供应商所有商品的总价格
                    'shipping_price'=>$shipping_price,//购买该供应商产品所应付出的邮费总额
                ];
                array_push($sub_arr,$sub);

            }else{ //其实这一步错误是因为数据错误导致的
                return $this->setStatusCode(9998)->respondWithError($this->message);
            }
        }


        \DB::beginTransaction(); //开启事务
        //生成订单分为如下三步：
        //(1)生成主订单（包含地址信息和总金额信息）
        $insert1 = \DB::table('ys_base_order')->insert($base);

        //(2)生成子订单（每个经销商一条记录，记录条数等于经销商个数
        $insert2 =  \DB::table('ys_sub_order')->insert($sub_arr);

        //(3)生成子订单和商品的对应表信息
        $insert3 = \DB::table('ys_order_goods')->insert($sub_goods);

        //(4)如果使用新地址，则把新地址写入到地址库中去
        if($request->flag == 1) { //使用新地址
            //判断该用户是否有地址记录，如果有则直接插入该地址即可，如果没有则插入该地址，并且设置为默认地址
            $is_exist = \DB::table('ys_user_addresses')->where('user_id',$user_id)->first();
            $is_default = empty($is_exist) ? 1 : 0;
            $insert4 = \DB::table('ys_user_addresses')->insert([

                'user_id' => $user_id,
                'name' => addslashes($request->name),
                'mobile' => $request->mobile,
                'area_id' => empty($request->area_id) ? "" : $request->area_id,
                'address' => $request->address,
                'created_at' => \DB::Raw('now()'),
                'updated_at' => \DB::Raw('now()'),
                'is_default' => $is_default,
            ]);
        }else{
            $insert4 = 1;
        }

        //(5)如果付款成功，则把购物车中已购买的商品清空 $delete_carId_arr
        $delete = \DB::table('ys_goods_car')->where('user_id',$user_id)->whereIn('id',$delete_carId_arr)->delete();


        //(6)购买成功后更新商品的销量和库存
        $update_arr_goods = []; //更新商品表是否成功
        $update_arr_ext = []; //更新商品扩展表是否成功


        foreach($complete_arr as $k=>$v){

            //更新销量
            $update1 = \DB::table('ys_goods')->where('id',$v['goods_id'])->update([
                'sales'=>$v['sales'] + $v['buy_num'],
                'updated_at'=>\DB::Raw('Now()')
            ]);

            //更新库存
            $update2 = \DB::table('ys_goods_extend')->where('id',$v['ext_id'])->update([
                'num'=>$v['rest_num'] - $v['buy_num'],
            ]);

            array_push($update_arr_goods,$update1);
            array_push($update_arr_ext,$update2);
        }


        //下面这个循环的目的是为了保证使用循环更新时的每一项都成功
        foreach($update_arr_goods as $k=>$v){
            if(!$v){
                \DB::rollBack();
                return $this->setStatusCode(9998)->respondWithError($this->message);
            }
        }
        foreach($update_arr_goods as $k=>$v){
            if(!$v){
                \DB::rollBack();
                return $this->setStatusCode(9998)->respondWithError($this->message);
            }
        }

        /**
         * 最后提交事务，并且返回主订单id
         */
        if ($insert1 && $insert2 && $insert3 && $insert4 && $delete) {
            \DB::commit();
            return  $this->respond($this->format(['order_id'=>$base_order_id]));
        }else {
            \DB::rollBack();
            return $this->setStatusCode(9998)->respondWithError($this->message);
        }


    }





}